# bos lab简介及环境配置

## bos lab介绍

bos的lab主要是实现一个用户态线程管理器和内存管理器。用户态线程管理器由三个部分组成，用户态线程创建，多种调度策略，同步机制。

bos lab的情况如下

- Lab 1: 用户态线程创建
- Lab 2: 内存管理
- Lab 3: 多种调度策略
- Lab 4: 同步机制

每一个lab中包含多个需要实现的功能点，以及一个自测的程序证明各个功能点可以正常执行。

## 环境配置

开发用户态的程序对开发环境要求不高，主要需要配置编译工具链，在虚拟机和裸机上开发体验基本一致。

## lab1 具体情况

用户态线程创建需要实现的功能及说明如下

1. 提供创建用户态线程的机制
   - 栈的空间大小自己定义
   - 线程的数量上线可以设置成一个常数
   - 注意要清理执行完的线程所占用的空间
2. 上下文切换
   - 了解上下文的概念，搞清楚包含哪些寄存器
   - 明白如何切换栈
   - 这个部分需要手写，不能借用外部函数
3. 线程状态的管理
   - 线程可以在多种状态之间来回切换，状态的数量最少有3个
4. random调度策略
   - 目前调度器不需要tick，上下文切换可以是显式调用
   - 调度策略随意发挥，没有任何要求，主要在lab2中实现
5. 测试程序
   - 测试程序需要同时创建多个线程，体现出用户态线程的并发能力
   - 测试时打印出上下文切换过程中信息，主要是提示切换的时机、切换前后线程的id、两个线程的状态

其他注意事项：

- 我们lab1实现的架构统一为x86
- 代码量<1000行，工程量不大，难点主要在于上下文切换
- 用户态线程模型不定，可以自由选择
- 用户态debug很方便，debug过程中善用gdb，注意编译时优化不要开的太高，学习基本的gdb命令，掌握gdb中reverse这个神器

## lab2 具体情况

用户态内存管理需要实现一个显式分配的动态内存分配器

1. 实现内存管理基本机制，拥有malloc和free，remalloc三个api
   - 开局向操作系统申请一片内存，之后手动管理这片内存区域
   - malloc
     - 申请一块指定大小的内存区域，这个api参数有一个，表示内存区域大小
     - 如果分配失败了，返回null
     - 如果成功了，就返回内存区域的地址
     - 如果当前分配器的内存用完了，不需要向操作系统申请新的内存
   - free
     - 销毁指定大小的内存区域，这个api的参数只有一个，表示内存区域位置
     - free的时候需要完成空闲块的合并
   - realloc
     - 改变一块已经申请内存区域的大小，这个api的参数有两个，第一个是需要改变的内存区域的地址，第二个是新的内存区域需要的大小
     - 如果分配失败了，返回null，旧的内存区域不发生改变
     - 如果成功了，就返回内存区域的地址
   - 只需要单线程支持就可以
2. 内存管理策略（以下三选一）
   - first fit，best fit，worst fit三种方法任选其一。此时采用的是链表的方法组织内存
   - 类似于Slab allocation，此时采用列表的方式组织内存
   - 类似于Buddy allocation，此时采用伙伴树的方法组织内存
3. 和lab1配合
   - 在lab1生成的一个线程中申请一块内存区域，并free掉。注意，此时只要求单线程。
   - 用户态内存库向操作系统申请128KB大小的内存，在用户态线程中用循环依次申请1，2，4，8，16...字节大小的内存，直到没有空余内存，内存库应该处理这种情况，并打出“run out of memory”的log

## lab3 具体情况

在lab1中，我们拥有了用户态线程库，但是驱动我们进行线程管理的动力是我们在线程里面显示调用schedule函数，而操作系统往往是采用时钟tick来管理线程，在这个lab中，我们会让大家首先实现tick机制，然后继承多种调度策略

1. 实现定时器的机制，作为tick和给线程提供定时能力的基础；
   - 定时器结构体需要自己手写，不能采用现成的定时器，表示时间相关的结构体可以采用现成的库；
   - 定时器的相关接口最少需要有create_timer、start_timer、stop_timer、delete_timer的api接口；
   - 需要借助外部机制通知定时器到期，但是不能借助外部机制完成处理定时器handler、组织管理定时器的任务；
   - 组织定时器队列的数据结构、定时器的类型、定时器的时钟源不做要求；
   - 需要考虑定时器过期的情况；
2. 在定时器的基础上产生tick作为驱动线程调度的动力，并实现相关调度策略
   - 采用tick机制改写lab1中的多线程管理，不在线程里面调用schedule机制；
   - tick的间隔时长自定义；
   - 实现FIFO，RR，彩票调度算法；
   - 注意在关键的代码段，防止时钟进入；

## lab4 具体情况

虽然我们可以通过关闭中断来实现UP（Uni-Processor）下临界区的互斥，但是这会引发安全、效率等诸多问题。在lab4中我们需要实现一个用户态的同步机制，这是完成多线程相互协作使用的最后一环。

1. 利用test&set或者Compare&Swap构建spinlock、mutex、condition variable
   - spinlock
     - spinlock的要求是如果锁正在占用，就需要一直忙等待；
   - mutex
     - mutex是睡眠锁，如果当前的线程被上锁了，就不需要等待了，直接让出当前的CPU，需要维护一个等待队列，然后把自己放在等待队列里面，等到下一次唤醒;
     - mutex实现时需要注意让出CPU和guard锁解锁这两个操作的原子性；
   - condition variable
     - 实现cv的wait，signal，Broadcast三个接口；
     - 注意wait使用时需要持锁；
2. 测试mutex/spinlock锁的正确性，以下二选一：
   - lab2配合
     - 在之前的lab2中，我们拥有了内存管理机制，但是当时我们不能支持多个线程同时使用这个内存分配器，现在我们可以拥有这个feature；
     - 现在我们可以用spinlock和mutex分别给内存分配器加上同步的机制，支持多个线程同时使用malloc；
       - 使用200个线程，每个线程分配1kB内存，在200个线程里面将申请到的内存每个字节依次填写为0-199；
       - 最后检查这些内存区域是否和分配预取的一致，重复以上实验50次；
       - 注：如果你自己写的用户库没有实现lab3中的tick调度功能，需要使用pthread线程库来创建线程；
   - lab3配合
     - 在之前的lab3中，我们拥有了具有“中断”功能的用户态线程库，但是多线程之间无法协作，在lab4中我们将其升级为具有同步机制的用户态线程库；
     - 分别使用spinlock/mutex，计算把0自加加100000次的结果是否正确；
3. 测试condition variable的正确性：
   - 搭建一个消费生产者模型，生产者在每次被唤醒时向一个全局变量依次写入1-100000，两个消费者线程获取这个全局变量的值，并打印；
   - 需要保证结果的正确性：在生产者写入和消费者读值后，需要对一个flag分别设0和1；在写入和读值前，需要在assert里面假设这个flag分别为1和0；
